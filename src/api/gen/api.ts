/* tslint:disable */
/* eslint-disable */
/**
 * TradingBot
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ConfigModel
 */
export interface ConfigModel {
    /**
     * 
     * @type {Array<string>}
     * @memberof ConfigModel
     */
    'intervals': Array<string>;
}
/**
 * 
 * @export
 * @interface ConfigSignalInputModel
 */
export interface ConfigSignalInputModel {
    /**
     * 
     * @type {number}
     * @memberof ConfigSignalInputModel
     */
    'port': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConfigSignalInputModel
     */
    'tokens': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConfigSignalInputModel
     */
    'intervals': Array<string>;
}
/**
 * 
 * @export
 * @interface StringObject
 */
export interface StringObject {
    /**
     * 
     * @type {string}
     * @memberof StringObject
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface TradingSetupConfigModel
 */
export interface TradingSetupConfigModel {
    /**
     * 
     * @type {string}
     * @memberof TradingSetupConfigModel
     */
    'firstToken': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupConfigModel
     */
    'secondToken': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupConfigModel
     */
    'interval': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupConfigModel
     */
    'signal': string;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupConfigModel
     */
    'terminationPercentageLoss'?: number;
    /**
     * 
     * @type {TradingTakeProfitConfigModel}
     * @memberof TradingSetupConfigModel
     */
    'takeProfit'?: TradingTakeProfitConfigModel;
    /**
     * 
     * @type {TradingStopLossConfigModel}
     * @memberof TradingSetupConfigModel
     */
    'stopLoss'?: TradingStopLossConfigModel;
    /**
     * 
     * @type {boolean}
     * @memberof TradingSetupConfigModel
     */
    'useLimitOrders': boolean;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupConfigModel
     */
    'limitOrderBuyOffset': number;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupConfigModel
     */
    'limitOrderSellOffset': number;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupConfigModel
     */
    'limitOrderCancelDueToChecksElapsed': number;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupConfigModel
     */
    'limitOrderCancelDueToTimeElapsed'?: number;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupConfigModel
     */
    'limitOrderCancelDueToPriceDivergence'?: string;
}
/**
 * 
 * @export
 * @interface TradingSetupModel
 */
export interface TradingSetupModel {
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'id': string;
    /**
     * 
     * @type {TradingSetupStatusType}
     * @memberof TradingSetupModel
     */
    'status': TradingSetupStatusType;
    /**
     * 
     * @type {TradingSetupConfigModel}
     * @memberof TradingSetupModel
     */
    'config': TradingSetupConfigModel;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'startingFirstAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'startingSecondAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'firstAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'secondAmount': string;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupModel
     */
    'lastUpdate': number;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'currentPriceAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'lowestPriceAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'highestPriceAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'tradeEntryPriceAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'tradeLowestPriceAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'tradeHighestPriceAmount': string;
    /**
     * 
     * @type {Array<TradingTransactionModel>}
     * @memberof TradingSetupModel
     */
    'transactions': Array<TradingTransactionModel>;
    /**
     * 
     * @type {object}
     * @memberof TradingSetupModel
     */
    'openTransactions': object;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TradingSetupStatusType = {
    Initial: 'INITIAL',
    Running: 'RUNNING',
    Terminated: 'TERMINATED'
} as const;

export type TradingSetupStatusType = typeof TradingSetupStatusType[keyof typeof TradingSetupStatusType];


/**
 * 
 * @export
 * @interface TradingStopLossConfigModel
 */
export interface TradingStopLossConfigModel {
    /**
     * 
     * @type {number}
     * @memberof TradingStopLossConfigModel
     */
    'percentage': number;
}
/**
 * 
 * @export
 * @interface TradingTakeProfitConfigModel
 */
export interface TradingTakeProfitConfigModel {
    /**
     * 
     * @type {number}
     * @memberof TradingTakeProfitConfigModel
     */
    'percentage': number;
    /**
     * 
     * @type {TradingTakeProfitTrailingStopConfigModel}
     * @memberof TradingTakeProfitConfigModel
     */
    'trailingStop'?: TradingTakeProfitTrailingStopConfigModel;
}
/**
 * 
 * @export
 * @interface TradingTakeProfitTrailingStopConfigModel
 */
export interface TradingTakeProfitTrailingStopConfigModel {
    /**
     * 
     * @type {number}
     * @memberof TradingTakeProfitTrailingStopConfigModel
     */
    'deltaPercentage': number;
    /**
     * 
     * @type {number}
     * @memberof TradingTakeProfitTrailingStopConfigModel
     */
    'hardLimitPercentage'?: number;
}
/**
 * 
 * @export
 * @interface TradingTransactionModel
 */
export interface TradingTransactionModel {
    /**
     * 
     * @type {boolean}
     * @memberof TradingTransactionModel
     */
    'buy': boolean;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'firstToken': string;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'secondToken': string;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'firstAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'secondAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'priceAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'transactionId': string;
    /**
     * 
     * @type {boolean}
     * @memberof TradingTransactionModel
     */
    'complete': boolean;
    /**
     * 
     * @type {number}
     * @memberof TradingTransactionModel
     */
    'checks': number;
    /**
     * 
     * @type {number}
     * @memberof TradingTransactionModel
     */
    'firstUpdateTimestamp': number;
    /**
     * 
     * @type {number}
     * @memberof TradingTransactionModel
     */
    'lastUpdateTimestamp': number;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appHealthCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health-check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appHealthCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appHealthCheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appHealthCheck(options?: any): AxiosPromise<void> {
            return localVarFp.appHealthCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appHealthCheck(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appHealthCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IdentityApi - axios parameter creator
 * @export
 */
export const IdentityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityGetConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityApi - functional programming interface
 * @export
 */
export const IdentityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityGetConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityGetConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdentityApi - factory interface
 * @export
 */
export const IdentityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityGetConfig(options?: any): AxiosPromise<ConfigModel> {
            return localVarFp.identityGetConfig(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdentityApi - object-oriented interface
 * @export
 * @class IdentityApi
 * @extends {BaseAPI}
 */
export class IdentityApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identityGetConfig(options?: AxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identityGetConfig(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PricesApi - axios parameter creator
 * @export
 */
export const PricesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} port 
         * @param {string} token 
         * @param {Array<string>} intervals 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesAdd: async (port: number, token: string, intervals: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'port' is not null or undefined
            assertParamExists('pricesAdd', 'port', port)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('pricesAdd', 'token', token)
            // verify required parameter 'intervals' is not null or undefined
            assertParamExists('pricesAdd', 'intervals', intervals)
            const localVarPath = `/prices/{port}/{token}/{intervals}`
                .replace(`{${"port"}}`, encodeURIComponent(String(port)))
                .replace(`{${"token"}}`, encodeURIComponent(String(token)))
                .replace(`{${"intervals"}}`, encodeURIComponent(String(intervals)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesGetAllPorts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/prices/allPorts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesGetAllTokens: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/prices/allTokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesGetPort: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('pricesGetPort', 'token', token)
            const localVarPath = `/prices/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesRemove: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('pricesRemove', 'token', token)
            const localVarPath = `/prices/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PricesApi - functional programming interface
 * @export
 */
export const PricesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PricesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} port 
         * @param {string} token 
         * @param {Array<string>} intervals 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricesAdd(port: number, token: string, intervals: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pricesAdd(port, token, intervals, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricesGetAllPorts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pricesGetAllPorts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricesGetAllTokens(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pricesGetAllTokens(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricesGetPort(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pricesGetPort(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricesRemove(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pricesRemove(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PricesApi - factory interface
 * @export
 */
export const PricesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PricesApiFp(configuration)
    return {
        /**
         * 
         * @param {number} port 
         * @param {string} token 
         * @param {Array<string>} intervals 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesAdd(port: number, token: string, intervals: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.pricesAdd(port, token, intervals, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesGetAllPorts(options?: any): AxiosPromise<Array<number>> {
            return localVarFp.pricesGetAllPorts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesGetAllTokens(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.pricesGetAllTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesGetPort(token: string, options?: any): AxiosPromise<number> {
            return localVarFp.pricesGetPort(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesRemove(token: string, options?: any): AxiosPromise<number> {
            return localVarFp.pricesRemove(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PricesApi - object-oriented interface
 * @export
 * @class PricesApi
 * @extends {BaseAPI}
 */
export class PricesApi extends BaseAPI {
    /**
     * 
     * @param {number} port 
     * @param {string} token 
     * @param {Array<string>} intervals 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public pricesAdd(port: number, token: string, intervals: Array<string>, options?: AxiosRequestConfig) {
        return PricesApiFp(this.configuration).pricesAdd(port, token, intervals, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public pricesGetAllPorts(options?: AxiosRequestConfig) {
        return PricesApiFp(this.configuration).pricesGetAllPorts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public pricesGetAllTokens(options?: AxiosRequestConfig) {
        return PricesApiFp(this.configuration).pricesGetAllTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public pricesGetPort(token: string, options?: AxiosRequestConfig) {
        return PricesApiFp(this.configuration).pricesGetPort(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public pricesRemove(token: string, options?: AxiosRequestConfig) {
        return PricesApiFp(this.configuration).pricesRemove(token, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SignalsApi - axios parameter creator
 * @export
 */
export const SignalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {ConfigSignalInputModel} configSignalInputModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsAdd: async (id: string, configSignalInputModel: ConfigSignalInputModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signalsAdd', 'id', id)
            // verify required parameter 'configSignalInputModel' is not null or undefined
            assertParamExists('signalsAdd', 'configSignalInputModel', configSignalInputModel)
            const localVarPath = `/signals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configSignalInputModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetAllPorts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/signals/allPorts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetAllSignals: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/signals/allSignals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetPort: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signalsGetPort', 'id', id)
            const localVarPath = `/signals/{id}/port`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetTokens: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signalsGetTokens', 'id', id)
            const localVarPath = `/signals/{id}/tokens`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signalsRemove', 'id', id)
            const localVarPath = `/signals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignalsApi - functional programming interface
 * @export
 */
export const SignalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SignalsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {ConfigSignalInputModel} configSignalInputModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signalsAdd(id: string, configSignalInputModel: ConfigSignalInputModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signalsAdd(id, configSignalInputModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signalsGetAllPorts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signalsGetAllPorts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signalsGetAllSignals(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signalsGetAllSignals(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signalsGetPort(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signalsGetPort(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signalsGetTokens(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signalsGetTokens(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signalsRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signalsRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SignalsApi - factory interface
 * @export
 */
export const SignalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SignalsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {ConfigSignalInputModel} configSignalInputModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsAdd(id: string, configSignalInputModel: ConfigSignalInputModel, options?: any): AxiosPromise<void> {
            return localVarFp.signalsAdd(id, configSignalInputModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetAllPorts(options?: any): AxiosPromise<Array<number>> {
            return localVarFp.signalsGetAllPorts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetAllSignals(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.signalsGetAllSignals(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetPort(id: string, options?: any): AxiosPromise<number> {
            return localVarFp.signalsGetPort(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetTokens(id: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.signalsGetTokens(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.signalsRemove(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SignalsApi - object-oriented interface
 * @export
 * @class SignalsApi
 * @extends {BaseAPI}
 */
export class SignalsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {ConfigSignalInputModel} configSignalInputModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalsApi
     */
    public signalsAdd(id: string, configSignalInputModel: ConfigSignalInputModel, options?: AxiosRequestConfig) {
        return SignalsApiFp(this.configuration).signalsAdd(id, configSignalInputModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalsApi
     */
    public signalsGetAllPorts(options?: AxiosRequestConfig) {
        return SignalsApiFp(this.configuration).signalsGetAllPorts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalsApi
     */
    public signalsGetAllSignals(options?: AxiosRequestConfig) {
        return SignalsApiFp(this.configuration).signalsGetAllSignals(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalsApi
     */
    public signalsGetPort(id: string, options?: AxiosRequestConfig) {
        return SignalsApiFp(this.configuration).signalsGetPort(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalsApi
     */
    public signalsGetTokens(id: string, options?: AxiosRequestConfig) {
        return SignalsApiFp(this.configuration).signalsGetTokens(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalsApi
     */
    public signalsRemove(id: string, options?: AxiosRequestConfig) {
        return SignalsApiFp(this.configuration).signalsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TradingApi - axios parameter creator
 * @export
 */
export const TradingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {string} startingFirstAmount 
         * @param {string} startingSecondAmount 
         * @param {TradingSetupConfigModel} tradingSetupConfigModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsAdd: async (id: string, startingFirstAmount: string, startingSecondAmount: string, tradingSetupConfigModel: TradingSetupConfigModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tradingSetupsAdd', 'id', id)
            // verify required parameter 'startingFirstAmount' is not null or undefined
            assertParamExists('tradingSetupsAdd', 'startingFirstAmount', startingFirstAmount)
            // verify required parameter 'startingSecondAmount' is not null or undefined
            assertParamExists('tradingSetupsAdd', 'startingSecondAmount', startingSecondAmount)
            // verify required parameter 'tradingSetupConfigModel' is not null or undefined
            assertParamExists('tradingSetupsAdd', 'tradingSetupConfigModel', tradingSetupConfigModel)
            const localVarPath = `/setups/{id}/{startingFirstAmount}/{startingSecondAmount}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"startingFirstAmount"}}`, encodeURIComponent(String(startingFirstAmount)))
                .replace(`{${"startingSecondAmount"}}`, encodeURIComponent(String(startingSecondAmount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tradingSetupConfigModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tradingSetupsGet', 'id', id)
            const localVarPath = `/setups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setups/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tradingSetupsRemove', 'id', id)
            const localVarPath = `/setups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradingApi - functional programming interface
 * @export
 */
export const TradingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {string} startingFirstAmount 
         * @param {string} startingSecondAmount 
         * @param {TradingSetupConfigModel} tradingSetupConfigModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradingSetupsAdd(id: string, startingFirstAmount: string, startingSecondAmount: string, tradingSetupConfigModel: TradingSetupConfigModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradingSetupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradingSetupsAdd(id, startingFirstAmount, startingSecondAmount, tradingSetupConfigModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradingSetupsGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradingSetupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradingSetupsGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradingSetupsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TradingSetupModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradingSetupsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradingSetupsRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradingSetupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradingSetupsRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TradingApi - factory interface
 * @export
 */
export const TradingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {string} startingFirstAmount 
         * @param {string} startingSecondAmount 
         * @param {TradingSetupConfigModel} tradingSetupConfigModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsAdd(id: string, startingFirstAmount: string, startingSecondAmount: string, tradingSetupConfigModel: TradingSetupConfigModel, options?: any): AxiosPromise<TradingSetupModel> {
            return localVarFp.tradingSetupsAdd(id, startingFirstAmount, startingSecondAmount, tradingSetupConfigModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsGet(id: string, options?: any): AxiosPromise<TradingSetupModel> {
            return localVarFp.tradingSetupsGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsGetAll(options?: any): AxiosPromise<Array<TradingSetupModel>> {
            return localVarFp.tradingSetupsGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsRemove(id: string, options?: any): AxiosPromise<TradingSetupModel> {
            return localVarFp.tradingSetupsRemove(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradingApi - object-oriented interface
 * @export
 * @class TradingApi
 * @extends {BaseAPI}
 */
export class TradingApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {string} startingFirstAmount 
     * @param {string} startingSecondAmount 
     * @param {TradingSetupConfigModel} tradingSetupConfigModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public tradingSetupsAdd(id: string, startingFirstAmount: string, startingSecondAmount: string, tradingSetupConfigModel: TradingSetupConfigModel, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).tradingSetupsAdd(id, startingFirstAmount, startingSecondAmount, tradingSetupConfigModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public tradingSetupsGet(id: string, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).tradingSetupsGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public tradingSetupsGetAll(options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).tradingSetupsGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public tradingSetupsRemove(id: string, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).tradingSetupsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionGetWalletFree: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/wallet/free`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionGetWalletLocked: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/wallet/locked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionGetWalletFree(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionGetWalletFree(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionGetWalletLocked(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionGetWalletLocked(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionGetWalletFree(options?: any): AxiosPromise<void> {
            return localVarFp.transactionGetWalletFree(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionGetWalletLocked(options?: any): AxiosPromise<void> {
            return localVarFp.transactionGetWalletLocked(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public transactionGetWalletFree(options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionGetWalletFree(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public transactionGetWalletLocked(options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionGetWalletLocked(options).then((request) => request(this.axios, this.basePath));
    }
}



