/* tslint:disable */
/* eslint-disable */
/**
 * TradingBot
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ConfigConnectionInputModel
 */
export interface ConfigConnectionInputModel {
    /**
     * 
     * @type {string}
     * @memberof ConfigConnectionInputModel
     */
    'host': string;
    /**
     * 
     * @type {number}
     * @memberof ConfigConnectionInputModel
     */
    'port': number;
}
/**
 * 
 * @export
 * @interface ConfigModel
 */
export interface ConfigModel {
    /**
     * 
     * @type {string}
     * @memberof ConfigModel
     */
    'default_host': string;
    /**
     * 
     * @type {number}
     * @memberof ConfigModel
     */
    'socket_timeout': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConfigModel
     */
    'intervals': Array<string>;
}
/**
 * 
 * @export
 * @interface ConfigSignalInputModel
 */
export interface ConfigSignalInputModel {
    /**
     * 
     * @type {string}
     * @memberof ConfigSignalInputModel
     */
    'host': string;
    /**
     * 
     * @type {number}
     * @memberof ConfigSignalInputModel
     */
    'port': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConfigSignalInputModel
     */
    'tokens': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConfigSignalInputModel
     */
    'intervals': Array<string>;
}
/**
 * 
 * @export
 * @interface PriceModel
 */
export interface PriceModel {
    /**
     * 
     * @type {string}
     * @memberof PriceModel
     */
    'tokenPair': string;
    /**
     * 
     * @type {string}
     * @memberof PriceModel
     */
    'interval': string;
    /**
     * 
     * @type {string}
     * @memberof PriceModel
     */
    'price': string;
    /**
     * 
     * @type {number}
     * @memberof PriceModel
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface SignalModel
 */
export interface SignalModel {
    /**
     * 
     * @type {string}
     * @memberof SignalModel
     */
    'tokenPair': string;
    /**
     * 
     * @type {string}
     * @memberof SignalModel
     */
    'interval': string;
    /**
     * 
     * @type {number}
     * @memberof SignalModel
     */
    'timestamp': number;
    /**
     * 
     * @type {number}
     * @memberof SignalModel
     */
    'action': number;
    /**
     * 
     * @type {number}
     * @memberof SignalModel
     */
    'certainty': number;
}
/**
 * 
 * @export
 * @interface StringObject
 */
export interface StringObject {
    /**
     * 
     * @type {string}
     * @memberof StringObject
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface TradingSetupActionModel
 */
export interface TradingSetupActionModel {
    /**
     * 
     * @type {TradingSetupActionType}
     * @memberof TradingSetupActionModel
     */
    'type': TradingSetupActionType;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupActionModel
     */
    'action': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TradingSetupActionType = {
    Manual: 'MANUAL',
    Signal: 'SIGNAL',
    Takeprofit: 'TAKEPROFIT',
    Stoploss: 'STOPLOSS',
    Termination: 'TERMINATION'
} as const;

export type TradingSetupActionType = typeof TradingSetupActionType[keyof typeof TradingSetupActionType];


/**
 * 
 * @export
 * @interface TradingSetupConfigModel
 */
export interface TradingSetupConfigModel {
    /**
     * 
     * @type {string}
     * @memberof TradingSetupConfigModel
     */
    'firstToken': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupConfigModel
     */
    'secondToken': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupConfigModel
     */
    'interval': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupConfigModel
     */
    'signal': string;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupConfigModel
     */
    'terminationPercentageLoss'?: number;
    /**
     * 
     * @type {TradingTakeProfitConfigModel}
     * @memberof TradingSetupConfigModel
     */
    'takeProfit'?: TradingTakeProfitConfigModel;
    /**
     * 
     * @type {TradingStopLossConfigModel}
     * @memberof TradingSetupConfigModel
     */
    'stopLoss'?: TradingStopLossConfigModel;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupConfigModel
     */
    'sellTimeout': number;
    /**
     * 
     * @type {boolean}
     * @memberof TradingSetupConfigModel
     */
    'useLimitOrders': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TradingSetupConfigModel
     */
    'useLimitMakerOrders': boolean;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupConfigModel
     */
    'limitOrderBuyOffset': number;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupConfigModel
     */
    'limitOrderSellOffset': number;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupConfigModel
     */
    'limitOrderCancelDueToChecksElapsed': number;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupConfigModel
     */
    'limitOrderCancelDueToTimeElapsed'?: number;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupConfigModel
     */
    'limitOrderCancelDueToPriceDivergence'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TradingSetupConfigModel
     */
    'isMarginAccount': boolean;
}
/**
 * 
 * @export
 * @interface TradingSetupModel
 */
export interface TradingSetupModel {
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'id': string;
    /**
     * 
     * @type {TradingSetupStatusType}
     * @memberof TradingSetupModel
     */
    'status': TradingSetupStatusType;
    /**
     * 
     * @type {TradingSetupConfigModel}
     * @memberof TradingSetupModel
     */
    'config': TradingSetupConfigModel;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'startingFirstAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'startingSecondAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'firstAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'secondAmount': string;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupModel
     */
    'updateTimestamp': number;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupModel
     */
    'timeoutTimestamp': number;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'currentPriceAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'lowestPriceAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'highestPriceAmount': string;
    /**
     * 
     * @type {TradingSetupActionModel}
     * @memberof TradingSetupModel
     */
    'currentAction': TradingSetupActionModel;
    /**
     * 
     * @type {TradingSetupActionModel}
     * @memberof TradingSetupModel
     */
    'manualOverrideAction'?: TradingSetupActionModel;
    /**
     * 
     * @type {Array<TradingSetupTradeModel>}
     * @memberof TradingSetupModel
     */
    'openTrades': Array<TradingSetupTradeModel>;
    /**
     * 
     * @type {Array<TradingSetupTradeModel>}
     * @memberof TradingSetupModel
     */
    'finishedTrades': Array<TradingSetupTradeModel>;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'feesAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'feesLastTradeAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupModel
     */
    'feesAsset': string;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupModel
     */
    'failedDueToMarketMaking': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TradingSetupStatusType = {
    Initial: 'INITIAL',
    Running: 'RUNNING',
    Paused: 'PAUSED',
    Terminating: 'TERMINATING',
    Terminated: 'TERMINATED'
} as const;

export type TradingSetupStatusType = typeof TradingSetupStatusType[keyof typeof TradingSetupStatusType];


/**
 * 
 * @export
 * @interface TradingSetupTradeModel
 */
export interface TradingSetupTradeModel {
    /**
     * 
     * @type {string}
     * @memberof TradingSetupTradeModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupTradeModel
     */
    'startingFirstAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupTradeModel
     */
    'startingSecondAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupTradeModel
     */
    'firstAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupTradeModel
     */
    'secondAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupTradeModel
     */
    'feesAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupTradeModel
     */
    'feesAsset': string;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupTradeModel
     */
    'startTimestamp': number;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupTradeModel
     */
    'updateTimestamp': number;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupTradeModel
     */
    'entryPriceAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupTradeModel
     */
    'lowestPriceAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupTradeModel
     */
    'highestPriceAmount': string;
    /**
     * 
     * @type {TradingSetupActionModel}
     * @memberof TradingSetupTradeModel
     */
    'currentAction': TradingSetupActionModel;
    /**
     * 
     * @type {TradingSetupActionModel}
     * @memberof TradingSetupTradeModel
     */
    'manualOverrideAction'?: TradingSetupActionModel;
    /**
     * 
     * @type {string}
     * @memberof TradingSetupTradeModel
     */
    'status': TradingSetupTradeModelStatusEnum;
    /**
     * 
     * @type {TradingTransactionModel}
     * @memberof TradingSetupTradeModel
     */
    'buyTransaction': TradingTransactionModel;
    /**
     * 
     * @type {TradingTransactionModel}
     * @memberof TradingSetupTradeModel
     */
    'sellTransactionPending': TradingTransactionModel;
    /**
     * 
     * @type {Array<TradingTransactionModel>}
     * @memberof TradingSetupTradeModel
     */
    'sellTransactionsComplete': Array<TradingTransactionModel>;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupTradeModel
     */
    'failedDueToMarketMaking': number;
    /**
     * 
     * @type {number}
     * @memberof TradingSetupTradeModel
     */
    'stopLossHardSellRetries': number;
}

export const TradingSetupTradeModelStatusEnum = {
    BuyPending: 'BUY_PENDING',
    BuyDone: 'BUY_DONE',
    SellPending: 'SELL_PENDING',
    SellPartiallyDone: 'SELL_PARTIALLY_DONE',
    Complete: 'COMPLETE',
    Cancelled: 'CANCELLED'
} as const;

export type TradingSetupTradeModelStatusEnum = typeof TradingSetupTradeModelStatusEnum[keyof typeof TradingSetupTradeModelStatusEnum];

/**
 * 
 * @export
 * @interface TradingStopLossConfigModel
 */
export interface TradingStopLossConfigModel {
    /**
     * 
     * @type {number}
     * @memberof TradingStopLossConfigModel
     */
    'percentage': number;
    /**
     * 
     * @type {number}
     * @memberof TradingStopLossConfigModel
     */
    'timeout': number;
    /**
     * 
     * @type {boolean}
     * @memberof TradingStopLossConfigModel
     */
    'isBasedOnMaxPrice': boolean;
    /**
     * 
     * @type {number}
     * @memberof TradingStopLossConfigModel
     */
    'retriesBeforeHardSell': number;
}
/**
 * 
 * @export
 * @interface TradingTakeProfitConfigModel
 */
export interface TradingTakeProfitConfigModel {
    /**
     * 
     * @type {number}
     * @memberof TradingTakeProfitConfigModel
     */
    'percentage': number;
    /**
     * 
     * @type {TradingTakeProfitTrailingStopConfigModel}
     * @memberof TradingTakeProfitConfigModel
     */
    'trailingStop'?: TradingTakeProfitTrailingStopConfigModel;
}
/**
 * 
 * @export
 * @interface TradingTakeProfitTrailingStopConfigModel
 */
export interface TradingTakeProfitTrailingStopConfigModel {
    /**
     * 
     * @type {number}
     * @memberof TradingTakeProfitTrailingStopConfigModel
     */
    'deltaPercentage': number;
    /**
     * 
     * @type {number}
     * @memberof TradingTakeProfitTrailingStopConfigModel
     */
    'hardLimitPercentage'?: number;
}
/**
 * 
 * @export
 * @interface TradingTransactionModel
 */
export interface TradingTransactionModel {
    /**
     * 
     * @type {boolean}
     * @memberof TradingTransactionModel
     */
    'buy': boolean;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'firstToken': string;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'secondToken': string;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'firstAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'secondAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'offeredAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'wantedPriceAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'priceAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'transactionId': string;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'commissionAmount': string;
    /**
     * 
     * @type {string}
     * @memberof TradingTransactionModel
     */
    'commissionAsset': string;
    /**
     * 
     * @type {boolean}
     * @memberof TradingTransactionModel
     */
    'complete': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TradingTransactionModel
     */
    'canceled': boolean;
    /**
     * 
     * @type {number}
     * @memberof TradingTransactionModel
     */
    'checks': number;
    /**
     * 
     * @type {number}
     * @memberof TradingTransactionModel
     */
    'firstUpdateTimestamp': number;
    /**
     * 
     * @type {number}
     * @memberof TradingTransactionModel
     */
    'lastUpdateTimestamp': number;
}
/**
 * 
 * @export
 * @interface WalletModel
 */
export interface WalletModel {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WalletModel
     */
    'amounts': { [key: string]: string; };
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appHealthCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health-check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appHealthCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appHealthCheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appHealthCheck(options?: any): AxiosPromise<void> {
            return localVarFp.appHealthCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appHealthCheck(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appHealthCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IdentityApi - axios parameter creator
 * @export
 */
export const IdentityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityGetConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityApi - functional programming interface
 * @export
 */
export const IdentityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityGetConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityGetConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdentityApi - factory interface
 * @export
 */
export const IdentityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityGetConfig(options?: any): AxiosPromise<ConfigModel> {
            return localVarFp.identityGetConfig(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdentityApi - object-oriented interface
 * @export
 * @class IdentityApi
 * @extends {BaseAPI}
 */
export class IdentityApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identityGetConfig(options?: AxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identityGetConfig(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PricesApi - axios parameter creator
 * @export
 */
export const PricesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} tokenPair 
         * @param {Array<string>} intervals 
         * @param {ConfigConnectionInputModel} configConnectionInputModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesAdd: async (tokenPair: string, intervals: Array<string>, configConnectionInputModel: ConfigConnectionInputModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenPair' is not null or undefined
            assertParamExists('pricesAdd', 'tokenPair', tokenPair)
            // verify required parameter 'intervals' is not null or undefined
            assertParamExists('pricesAdd', 'intervals', intervals)
            // verify required parameter 'configConnectionInputModel' is not null or undefined
            assertParamExists('pricesAdd', 'configConnectionInputModel', configConnectionInputModel)
            const localVarPath = `/prices/{tokenPair}/{intervals}`
                .replace(`{${"tokenPair"}}`, encodeURIComponent(String(tokenPair)))
                .replace(`{${"intervals"}}`, encodeURIComponent(String(intervals)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configConnectionInputModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tokenPair 
         * @param {string} interval 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesGetAll: async (tokenPair: string, interval: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenPair' is not null or undefined
            assertParamExists('pricesGetAll', 'tokenPair', tokenPair)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('pricesGetAll', 'interval', interval)
            const localVarPath = `/prices/{tokenPair}/{interval}/all`
                .replace(`{${"tokenPair"}}`, encodeURIComponent(String(tokenPair)))
                .replace(`{${"interval"}}`, encodeURIComponent(String(interval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesGetAllTokens: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/prices/allTokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tokenPair 
         * @param {string} interval 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesGetLatest: async (tokenPair: string, interval: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenPair' is not null or undefined
            assertParamExists('pricesGetLatest', 'tokenPair', tokenPair)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('pricesGetLatest', 'interval', interval)
            const localVarPath = `/prices/{tokenPair}/{interval}/latest`
                .replace(`{${"tokenPair"}}`, encodeURIComponent(String(tokenPair)))
                .replace(`{${"interval"}}`, encodeURIComponent(String(interval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tokenPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesRemove: async (tokenPair: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenPair' is not null or undefined
            assertParamExists('pricesRemove', 'tokenPair', tokenPair)
            const localVarPath = `/prices/{tokenPair}`
                .replace(`{${"tokenPair"}}`, encodeURIComponent(String(tokenPair)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PricesApi - functional programming interface
 * @export
 */
export const PricesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PricesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} tokenPair 
         * @param {Array<string>} intervals 
         * @param {ConfigConnectionInputModel} configConnectionInputModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricesAdd(tokenPair: string, intervals: Array<string>, configConnectionInputModel: ConfigConnectionInputModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pricesAdd(tokenPair, intervals, configConnectionInputModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} tokenPair 
         * @param {string} interval 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricesGetAll(tokenPair: string, interval: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PriceModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pricesGetAll(tokenPair, interval, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricesGetAllTokens(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pricesGetAllTokens(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} tokenPair 
         * @param {string} interval 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricesGetLatest(tokenPair: string, interval: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pricesGetLatest(tokenPair, interval, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} tokenPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricesRemove(tokenPair: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pricesRemove(tokenPair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PricesApi - factory interface
 * @export
 */
export const PricesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PricesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} tokenPair 
         * @param {Array<string>} intervals 
         * @param {ConfigConnectionInputModel} configConnectionInputModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesAdd(tokenPair: string, intervals: Array<string>, configConnectionInputModel: ConfigConnectionInputModel, options?: any): AxiosPromise<void> {
            return localVarFp.pricesAdd(tokenPair, intervals, configConnectionInputModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tokenPair 
         * @param {string} interval 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesGetAll(tokenPair: string, interval: string, options?: any): AxiosPromise<Array<PriceModel>> {
            return localVarFp.pricesGetAll(tokenPair, interval, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesGetAllTokens(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.pricesGetAllTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tokenPair 
         * @param {string} interval 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesGetLatest(tokenPair: string, interval: string, options?: any): AxiosPromise<PriceModel> {
            return localVarFp.pricesGetLatest(tokenPair, interval, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tokenPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesRemove(tokenPair: string, options?: any): AxiosPromise<string> {
            return localVarFp.pricesRemove(tokenPair, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PricesApi - object-oriented interface
 * @export
 * @class PricesApi
 * @extends {BaseAPI}
 */
export class PricesApi extends BaseAPI {
    /**
     * 
     * @param {string} tokenPair 
     * @param {Array<string>} intervals 
     * @param {ConfigConnectionInputModel} configConnectionInputModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public pricesAdd(tokenPair: string, intervals: Array<string>, configConnectionInputModel: ConfigConnectionInputModel, options?: AxiosRequestConfig) {
        return PricesApiFp(this.configuration).pricesAdd(tokenPair, intervals, configConnectionInputModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tokenPair 
     * @param {string} interval 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public pricesGetAll(tokenPair: string, interval: string, options?: AxiosRequestConfig) {
        return PricesApiFp(this.configuration).pricesGetAll(tokenPair, interval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public pricesGetAllTokens(options?: AxiosRequestConfig) {
        return PricesApiFp(this.configuration).pricesGetAllTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tokenPair 
     * @param {string} interval 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public pricesGetLatest(tokenPair: string, interval: string, options?: AxiosRequestConfig) {
        return PricesApiFp(this.configuration).pricesGetLatest(tokenPair, interval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tokenPair 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricesApi
     */
    public pricesRemove(tokenPair: string, options?: AxiosRequestConfig) {
        return PricesApiFp(this.configuration).pricesRemove(tokenPair, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SignalsApi - axios parameter creator
 * @export
 */
export const SignalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {ConfigSignalInputModel} configSignalInputModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsAdd: async (id: string, configSignalInputModel: ConfigSignalInputModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signalsAdd', 'id', id)
            // verify required parameter 'configSignalInputModel' is not null or undefined
            assertParamExists('signalsAdd', 'configSignalInputModel', configSignalInputModel)
            const localVarPath = `/signals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configSignalInputModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} tokenPair 
         * @param {string} interval 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetAll: async (id: string, tokenPair: string, interval: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signalsGetAll', 'id', id)
            // verify required parameter 'tokenPair' is not null or undefined
            assertParamExists('signalsGetAll', 'tokenPair', tokenPair)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('signalsGetAll', 'interval', interval)
            const localVarPath = `/signals/{id}/{tokenPair}/{interval}/all`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"tokenPair"}}`, encodeURIComponent(String(tokenPair)))
                .replace(`{${"interval"}}`, encodeURIComponent(String(interval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetAllSignals: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/signals/allSignals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} tokenPair 
         * @param {string} interval 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetLatest: async (id: string, tokenPair: string, interval: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signalsGetLatest', 'id', id)
            // verify required parameter 'tokenPair' is not null or undefined
            assertParamExists('signalsGetLatest', 'tokenPair', tokenPair)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('signalsGetLatest', 'interval', interval)
            const localVarPath = `/signals/{id}/{tokenPair}/{interval}/latest`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"tokenPair"}}`, encodeURIComponent(String(tokenPair)))
                .replace(`{${"interval"}}`, encodeURIComponent(String(interval)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetTokens: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signalsGetTokens', 'id', id)
            const localVarPath = `/signals/{id}/tokens`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signalsRemove', 'id', id)
            const localVarPath = `/signals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignalsApi - functional programming interface
 * @export
 */
export const SignalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SignalsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {ConfigSignalInputModel} configSignalInputModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signalsAdd(id: string, configSignalInputModel: ConfigSignalInputModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signalsAdd(id, configSignalInputModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} tokenPair 
         * @param {string} interval 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signalsGetAll(id: string, tokenPair: string, interval: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SignalModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signalsGetAll(id, tokenPair, interval, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signalsGetAllSignals(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signalsGetAllSignals(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} tokenPair 
         * @param {string} interval 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signalsGetLatest(id: string, tokenPair: string, interval: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignalModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signalsGetLatest(id, tokenPair, interval, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signalsGetTokens(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signalsGetTokens(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signalsRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signalsRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SignalsApi - factory interface
 * @export
 */
export const SignalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SignalsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {ConfigSignalInputModel} configSignalInputModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsAdd(id: string, configSignalInputModel: ConfigSignalInputModel, options?: any): AxiosPromise<void> {
            return localVarFp.signalsAdd(id, configSignalInputModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} tokenPair 
         * @param {string} interval 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetAll(id: string, tokenPair: string, interval: string, options?: any): AxiosPromise<Array<SignalModel>> {
            return localVarFp.signalsGetAll(id, tokenPair, interval, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetAllSignals(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.signalsGetAllSignals(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} tokenPair 
         * @param {string} interval 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetLatest(id: string, tokenPair: string, interval: string, options?: any): AxiosPromise<SignalModel> {
            return localVarFp.signalsGetLatest(id, tokenPair, interval, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsGetTokens(id: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.signalsGetTokens(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signalsRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.signalsRemove(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SignalsApi - object-oriented interface
 * @export
 * @class SignalsApi
 * @extends {BaseAPI}
 */
export class SignalsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {ConfigSignalInputModel} configSignalInputModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalsApi
     */
    public signalsAdd(id: string, configSignalInputModel: ConfigSignalInputModel, options?: AxiosRequestConfig) {
        return SignalsApiFp(this.configuration).signalsAdd(id, configSignalInputModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} tokenPair 
     * @param {string} interval 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalsApi
     */
    public signalsGetAll(id: string, tokenPair: string, interval: string, options?: AxiosRequestConfig) {
        return SignalsApiFp(this.configuration).signalsGetAll(id, tokenPair, interval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalsApi
     */
    public signalsGetAllSignals(options?: AxiosRequestConfig) {
        return SignalsApiFp(this.configuration).signalsGetAllSignals(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} tokenPair 
     * @param {string} interval 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalsApi
     */
    public signalsGetLatest(id: string, tokenPair: string, interval: string, options?: AxiosRequestConfig) {
        return SignalsApiFp(this.configuration).signalsGetLatest(id, tokenPair, interval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalsApi
     */
    public signalsGetTokens(id: string, options?: AxiosRequestConfig) {
        return SignalsApiFp(this.configuration).signalsGetTokens(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalsApi
     */
    public signalsRemove(id: string, options?: AxiosRequestConfig) {
        return SignalsApiFp(this.configuration).signalsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TradingApi - axios parameter creator
 * @export
 */
export const TradingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {string} startingFirstAmount 
         * @param {string} startingSecondAmount 
         * @param {TradingSetupConfigModel} tradingSetupConfigModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsAdd: async (id: string, startingFirstAmount: string, startingSecondAmount: string, tradingSetupConfigModel: TradingSetupConfigModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tradingSetupsAdd', 'id', id)
            // verify required parameter 'startingFirstAmount' is not null or undefined
            assertParamExists('tradingSetupsAdd', 'startingFirstAmount', startingFirstAmount)
            // verify required parameter 'startingSecondAmount' is not null or undefined
            assertParamExists('tradingSetupsAdd', 'startingSecondAmount', startingSecondAmount)
            // verify required parameter 'tradingSetupConfigModel' is not null or undefined
            assertParamExists('tradingSetupsAdd', 'tradingSetupConfigModel', tradingSetupConfigModel)
            const localVarPath = `/setups/{id}/{startingFirstAmount}/{startingSecondAmount}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"startingFirstAmount"}}`, encodeURIComponent(String(startingFirstAmount)))
                .replace(`{${"startingSecondAmount"}}`, encodeURIComponent(String(startingSecondAmount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tradingSetupConfigModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tradingSetupsGet', 'id', id)
            const localVarPath = `/setups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setups/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tradingSetupsRemove', 'id', id)
            const localVarPath = `/setups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TradingSetupModel} tradingSetupModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsUpdate: async (tradingSetupModel: TradingSetupModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tradingSetupModel' is not null or undefined
            assertParamExists('tradingSetupsUpdate', 'tradingSetupModel', tradingSetupModel)
            const localVarPath = `/setups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tradingSetupModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradingApi - functional programming interface
 * @export
 */
export const TradingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {string} startingFirstAmount 
         * @param {string} startingSecondAmount 
         * @param {TradingSetupConfigModel} tradingSetupConfigModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradingSetupsAdd(id: string, startingFirstAmount: string, startingSecondAmount: string, tradingSetupConfigModel: TradingSetupConfigModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradingSetupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradingSetupsAdd(id, startingFirstAmount, startingSecondAmount, tradingSetupConfigModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradingSetupsGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradingSetupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradingSetupsGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradingSetupsGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TradingSetupModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradingSetupsGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradingSetupsRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradingSetupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradingSetupsRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TradingSetupModel} tradingSetupModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradingSetupsUpdate(tradingSetupModel: TradingSetupModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradingSetupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradingSetupsUpdate(tradingSetupModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TradingApi - factory interface
 * @export
 */
export const TradingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {string} startingFirstAmount 
         * @param {string} startingSecondAmount 
         * @param {TradingSetupConfigModel} tradingSetupConfigModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsAdd(id: string, startingFirstAmount: string, startingSecondAmount: string, tradingSetupConfigModel: TradingSetupConfigModel, options?: any): AxiosPromise<TradingSetupModel> {
            return localVarFp.tradingSetupsAdd(id, startingFirstAmount, startingSecondAmount, tradingSetupConfigModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsGet(id: string, options?: any): AxiosPromise<TradingSetupModel> {
            return localVarFp.tradingSetupsGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsGetAll(options?: any): AxiosPromise<Array<TradingSetupModel>> {
            return localVarFp.tradingSetupsGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsRemove(id: string, options?: any): AxiosPromise<TradingSetupModel> {
            return localVarFp.tradingSetupsRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TradingSetupModel} tradingSetupModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradingSetupsUpdate(tradingSetupModel: TradingSetupModel, options?: any): AxiosPromise<TradingSetupModel> {
            return localVarFp.tradingSetupsUpdate(tradingSetupModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradingApi - object-oriented interface
 * @export
 * @class TradingApi
 * @extends {BaseAPI}
 */
export class TradingApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {string} startingFirstAmount 
     * @param {string} startingSecondAmount 
     * @param {TradingSetupConfigModel} tradingSetupConfigModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public tradingSetupsAdd(id: string, startingFirstAmount: string, startingSecondAmount: string, tradingSetupConfigModel: TradingSetupConfigModel, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).tradingSetupsAdd(id, startingFirstAmount, startingSecondAmount, tradingSetupConfigModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public tradingSetupsGet(id: string, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).tradingSetupsGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public tradingSetupsGetAll(options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).tradingSetupsGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public tradingSetupsRemove(id: string, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).tradingSetupsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TradingSetupModel} tradingSetupModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public tradingSetupsUpdate(tradingSetupModel: TradingSetupModel, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).tradingSetupsUpdate(tradingSetupModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionConvertAllBTC: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/convertAllBTC`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionForceBuy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transactionForceBuy', 'id', id)
            const localVarPath = `/transactions/forceBuy/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionForceSell: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transactionForceSell', 'id', id)
            const localVarPath = `/transactions/forceSell/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionGetWalletFree: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/wallet/free`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionGetWalletLocked: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/wallet/locked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionGetWalletMarginFree: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/walletMargin/free`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionGetWalletMarginLocked: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/walletMargin/locked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionTogglePause: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transactionTogglePause', 'id', id)
            const localVarPath = `/transactions/togglePause/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionConvertAllBTC(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionConvertAllBTC(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionForceBuy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradingSetupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionForceBuy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionForceSell(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradingSetupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionForceSell(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionGetWalletFree(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionGetWalletFree(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionGetWalletLocked(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionGetWalletLocked(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionGetWalletMarginFree(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionGetWalletMarginFree(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionGetWalletMarginLocked(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionGetWalletMarginLocked(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionTogglePause(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradingSetupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionTogglePause(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionConvertAllBTC(options?: any): AxiosPromise<WalletModel> {
            return localVarFp.transactionConvertAllBTC(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionForceBuy(id: string, options?: any): AxiosPromise<TradingSetupModel> {
            return localVarFp.transactionForceBuy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionForceSell(id: string, options?: any): AxiosPromise<TradingSetupModel> {
            return localVarFp.transactionForceSell(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionGetWalletFree(options?: any): AxiosPromise<WalletModel> {
            return localVarFp.transactionGetWalletFree(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionGetWalletLocked(options?: any): AxiosPromise<WalletModel> {
            return localVarFp.transactionGetWalletLocked(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionGetWalletMarginFree(options?: any): AxiosPromise<WalletModel> {
            return localVarFp.transactionGetWalletMarginFree(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionGetWalletMarginLocked(options?: any): AxiosPromise<WalletModel> {
            return localVarFp.transactionGetWalletMarginLocked(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionTogglePause(id: string, options?: any): AxiosPromise<TradingSetupModel> {
            return localVarFp.transactionTogglePause(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public transactionConvertAllBTC(options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionConvertAllBTC(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public transactionForceBuy(id: string, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionForceBuy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public transactionForceSell(id: string, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionForceSell(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public transactionGetWalletFree(options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionGetWalletFree(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public transactionGetWalletLocked(options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionGetWalletLocked(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public transactionGetWalletMarginFree(options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionGetWalletMarginFree(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public transactionGetWalletMarginLocked(options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionGetWalletMarginLocked(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public transactionTogglePause(id: string, options?: AxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionTogglePause(id, options).then((request) => request(this.axios, this.basePath));
    }
}



